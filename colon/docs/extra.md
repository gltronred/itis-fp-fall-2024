# Дополнительные опции для Colon

Смотрите описание тех опций, которые вы выбрали. Если ещё не выбрали - зафиксируйте эти опции, иначе никакая ваша работа не будет засчитана. Не забывайте выкладывать процесс вашей работы в виде коммитов.

# Цикл `BEGIN ... UNTIL`

Цикл `BEGIN ... UNTIL` является еще одним способом организации повторяющихся действий. Он отличается от цикла `DO ... LOOP` тем, что количество итераций не фиксировано заранее, а определяется условием, проверяемым после каждой итерации.

Синтаксис использования цикла `BEGIN ... UNTIL` следующий:
```
BEGIN <операции> UNTIL
```
Здесь `<операции>` — это набор команд, которые будут выполняться повторно до тех пор, пока вершина стека в момент выполнения `UNTIL` не будет истинной. Условие проверяется после каждой итерации.

Так же, как и цикл `DO ... LOOP`, цикл `BEGIN ... UNTIL` доступен только в определениях слов.

Пример использования цикла `BEGIN ... UNTIL`:
```
: count
0
BEGIN 
  DUP .
  1 +
  DUP 10 =
UNTIL ;
count
> 0 1 2 3 4 5 6 7 8 9 ok 
| 10 <- Top
```

# Проверка комментариев про стек

При объявлении новых слов должны автоматически проверяться комментарии вида `( a
b c -- d e )` (показывающие, сколько слов снимается со стека и сколько
кладётся). Должно быть предусмотрено два режима: в одном выдаётся ошибка, если
слово невозможно проверить, в другом - только предупреждение.

# Массивы
Для работы с массивами в языке Forth используются слова ~CELLS~ и ~ALLOT~.

- Слово ~CREATE~ используется для создания новой константы или переменной, но
  также может использоваться для выделения памяти под массив. Для этого после
  ~CREATE~ указывается имя массива, а затем слово ~ALLOT~, которое выделяет
  необходимое количество ячеек памяти.
- Слово ~CELLS~ используется для расчета количества ячеек, необходимых для
  хранения массива из заданного количества элементов. Оно умножает свое аргумент
  на размер ячейки (~CELL~).

Пример создания и использования массива:
#+BEGIN_SRC
CREATE my-array 10 CELLS ALLOT my-array 3 CELLS + 42 ! my-array 3 CELLS + @ > ok
> ok | 42 <- Top
#+END_SRC

В этом примере создается массив ~my-array~ из 10 ячеек, затем в 4-й ячейку
записывается значение 42 и считывается обратно.

Также можно использовать слова ~+!~, ~-!~, ~*!~, ~/!~, ~MOD!~ для работы с
элементами массива:
#+BEGIN_SRC
CREATE my-array2 5 CELLS ALLOT my-array2 2 CELLS + 10 ! my-array2 2 CELLS + 5 +!
my-array2 2 CELLS + @ > ok > ok | 15 <- Top
#+END_SRC

# Работа с графикой

Для работы с графикой используется специальная переменная, адрес которой находится в слове ~GRAPHICS~. Значение 0 или 1 в переменной задаёт состояние левого верхнего пикселя. Следующие адреса содержат развертку кадра слева направо и сверху вниз. 

Слова ~WIDTH~ и ~HEIGHT~ содержат, соответственно, ширину и высоту растра.

Слово ~LAST-KEY~ возвращает код последней нажатой клавиши без прерывания работы программы.

Для реализации можно использовать, например, библиотеку [gloss](https://hackage.haskell.org/package/gloss)

# Конкурентное программирование

Для запуска кода на нескольких ядрах 

~RX~, ~G!~ (3)

# Пошаговая отладка

получение текущего стека, памяти, словаря и т.п. (3)

# Компиляция (8)

# REPL с readline (5)

# LSP с хотя бы одной функцией (6)

# json + api на типах + htmx = веб-интерпретатор (6)

# Multi-exit loops (4 если с парсингом)

# Конструкция ~case of endof endcase~ (3 если с парсингом)

# Арифметические операции над числами с плавающей запятой (2)
