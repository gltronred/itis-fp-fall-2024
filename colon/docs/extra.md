# Дополнительные опции для Colon

Смотрите описание тех опций, которые вы выбрали. Если ещё не выбрали - зафиксируйте эти опции, иначе никакая ваша работа не будет засчитана. Не забывайте выкладывать процесс вашей работы в виде коммитов.

# Цикл `BEGIN ... UNTIL`

Цикл `BEGIN ... UNTIL` является еще одним способом организации повторяющихся действий. Он отличается от цикла `DO ... LOOP` тем, что количество итераций не фиксировано заранее, а определяется условием, проверяемым после каждой итерации.

Синтаксис использования цикла `BEGIN ... UNTIL` следующий:
```
BEGIN <операции> UNTIL
```
Здесь `<операции>` — это набор команд, которые будут выполняться повторно до тех пор, пока вершина стека в момент выполнения `UNTIL` не будет истинной. Условие проверяется после каждой итерации.

Так же, как и цикл `DO ... LOOP`, цикл `BEGIN ... UNTIL` доступен только в определениях слов.

Пример использования цикла `BEGIN ... UNTIL`:
```
: count
0
BEGIN 
  DUP .
  1 +
  DUP 10 =
UNTIL ;
count
> 0 1 2 3 4 5 6 7 8 9 ok 
| 10 <- Top
```

# Проверка комментариев про стек

При объявлении новых слов должны автоматически проверяться комментарии вида `( a
b c -- d e )` (показывающие, сколько слов снимается со стека и сколько
кладётся). Должно быть предусмотрено два режима: в одном выдаётся ошибка, если
слово невозможно проверить, в другом - только предупреждение.

# Массивы
Для работы с массивами в языке Forth используются слова `CELLS` и `ALLOT`.

- Слово `CREATE` используется для создания новой константы или переменной, но
  также может использоваться для выделения памяти под массив. Для этого после
  `CREATE` указывается имя массива, а затем слово `ALLOT`, которое выделяет
  необходимое количество ячеек памяти.
- Слово `CELLS` используется для расчета количества ячеек, необходимых для
  хранения массива из заданного количества элементов. Оно умножает верхний
  элемент стека на размер ячейки и кладёт полученное значение размера обратно на
  стек.

Пример создания и использования массива:
```
CREATE my-array 10 CELLS ALLOT 
my-array 3 CELLS + 42 ! 
my-array 3 CELLS + @ 
> ok
> ok 
> ok
| 42 <- Top
```

В этом примере создается массив `my-array` из 10 ячеек, затем в 4-й ячейку
записывается значение 42 и считывается обратно.

Также можно использовать слова `+!`, `-!`, `*!`, `/!`, `MOD!` для работы с
элементами массива:
```
CREATE my-array2 5 CELLS ALLOT 
my-array2 2 CELLS + 10 ! 
my-array2 2 CELLS + 5 +!
my-array2 2 CELLS + @ 
> ok 
> ok
> ok
> ok 
| 15 <- Top
```

# Работа с графикой

Для работы с графикой используется специальная переменная, адрес которой находится в слове `GRAPHICS`. Значение 0 или 1 в переменной задаёт состояние левого верхнего пикселя. Следующие адреса содержат развертку кадра слева направо и сверху вниз. 

Слова `WIDTH` и `HEIGHT` содержат, соответственно, ширину и высоту растра.

Слово `LAST-KEY` возвращает код последней нажатой клавиши без прерывания работы программы.

Для реализации можно использовать, например, библиотеку [gloss](https://hackage.haskell.org/package/gloss)

# Компиляция

В языке программирования Forth существует два основных режима выполнения кода:
контекст компиляции и контекст интерпретации. Вашей задачей будет реализация
контекста компиляции (и, возможно, изменений в реализации контекста
интерпретации) для реализации Colon.

## Контекст интерпретации

Контекст интерпретации — это режим, в котором код выполняется непосредственно
при его вводе или чтении из файла. Когда вы работаете в контексте интерпретации,
каждая команда (слово) исполняется сразу после ее прочтения. Этот режим удобен
для тестирования отдельных команд, отладки программ и выполнения простых
операций.

В этом режиме слова (команды) интерпретируются и выполняются пошагово. Например,
если вы введете `2 3 + .`, Forth сначала положит на стек число `2`, затем число
`3`, после этого выполнит команду сложения `+` (которая берет два верхних
элемента со стека, складывает их и кладет результат обратно в стек), а затем
команда `.` выведет результат суммирования.

## Контекст компиляции

Контекст компиляции — это режим, в котором код не выполняется сразу, а вместо
этого преобразуется в форму, которую можно выполнить позже. Когда Forth работает
в контексте компиляции, слова не выполняются напрямую; вместо этого они
преобразуются в машинный код, которое может быть выполнено при запуске
скомпилированной программы.

Чтобы переключиться между контекстом интерпретации и контекстом компиляции в
Forth, используются особые слова. Например, слово `:` начинает определение
нового слова (переключает в контекст компиляции), а слово `;` завершает его
(возвращая в контекст интерпретации).

## Пример для цикла

Например, компиляция слов `DO`, `I` и `LOOP` включает в себя создание
специальной структуры на стеке и генерацию машинного кода для управления циклом.

### DO
Когда слово `DO` компилируется, оно ожидает двух чисел на стеке: начального
значения (`n1`) и конечного значения (`n2`) счетчика цикла. Эти числа удаляются
со стека, и затем Forth генерирует машинный код, который:

1. Сохраняет текущее значение счетчика в специальной области памяти (называемой
   "областью данных").
2. Устанавливает начальное значение (`n1`) счетчика.
3. Создает метку для начала цикла.

### I
Слово `I`, когда компилируется, генерирует машинный код, который:

1. Загружает текущее значение счетчика из области данных.
2. Помещает его на вершину стека.

### LOOP
Когда слово `LOOP` компилируется, оно генерирует машинный код, который:

1. Увеличивает значение счетчика.
2. Сравнивает новое значение с конечным значением (`n2`).
3. Если значение счетчика меньше `n2`, прыгает к метке начала цикла
   (`loop_start`).

Как можно убедиться, в итоге не требуется реализовывать интерпретатор, который
бы хранил и интерпретировал тело цикла, все инструкции компилируются сразу. Это
же объясняет, почему некоторые слова можно использовать только в контексте
компиляции. Аналогичная идея используется для компиляции новых слов, условных
операторов и т.д.

Для более простой кодогенерации вы можете использовать, например, библиотеку
[llvm-tf](https://hackage.haskell.org/package/llvm-tf) или аналогичную.

# REPL с readline

REPL (Read-Eval-Print Loop) - это интерактивная среда программирования, которая
позволяет пользователям вводить команды или выражения, исполнять их и сразу же
видеть результат. REPL обычно используется для разработки, тестирования и
отладки программ.

REPL работает следующим образом:

1. *Чтение* (Read): Пользователь вводит команду или выражение в интерактивной
   среде.
2. *Вычисление* (Eval): Среда вычисляет введенную команду или выражение.
3. *Печать* (Print): Результат вычисления выводится на экран.
4. *Цикл* (Loop): Среда возвращается к шагу 1, ожидая следующей команды от
   пользователя.

Примерами REPL являются интерактивные оболочки GHCi, Python и многих других
языков программирования.

Readline - это библиотека программного обеспечения, которая предоставляет
функциональность для чтения ввода пользователя в терминале или командной строке.
Readline позволяет разработчикам создавать интерактивные приложения, которые
могут читать и обрабатывать ввод пользователя.

Readline предлагает следующие возможности:

+ *Чтение строки*: Чтение одной строки ввода от пользователя.
+ *История команд*: Сохранение истории введенных команд для повторного
  использования.
+ *Автозаполнение*: Автозаполнение частично введенной команды.
+ *Управление курсором*: Позволяет пользователю перемещать курсор по строке
  ввода.
+ *Горячие клавиши*: Поддержка горячих клавиш для выполнения определенных
  действий.

Readline часто используется в сочетании с REPL для создания интерактивных сред
программирования. Например, GHCi использует Readline для чтения ввода
пользователя в своей интерактивной оболочке.

Для реализации функциональности Readline можно подключить библиотеку
[haskeline](https://hackage.haskell.org/package/haskeline) или
[isocline](https://hackage.haskell.org/package/isocline).

# LSP с хотя бы одной функцией (6)

LSP - это протокол, который позволяет редакторам кода и IDE взаимодействовать с
серверами языка для получения дополнительной функциональности и информации о
коде. LSP позволяет редакторам кода и IDE запрашивать у серверов языка
информацию о коде, например:

+ *Автозаполнение кода*: Сервер LSP может предложить список доступных методов и
  функций для объекта, когда пользователь вводит точку после имени объекта.
+ *Проверка синтаксиса и ошибок*: Сервер LSP может проверять синтаксис кода и
  выделять ошибки в реальном времени, когда пользователь вводит код.
+ *Навигация по коду*: Сервер LSP может позволить пользователям перейти к
  определению функции или переменной, нажав на её имя в коде.
+ *Выделение синтаксиса и форматирование кода*: Сервер LSP может выделять
  синтаксис кода (для его подсветки в редакторе) и форматировать его согласно
  установленным правилам.
+ *Информация о типах данных и переменных*: Сервер LSP может указывать тип
  переменной и выражения по наведению на её имя.

LSP имеет несколько преимуществ, включая:

+ *Унификация функциональности*: LSP позволяет редакторам кода и IDE
  предоставлять одинаковую функциональность для различных языков
  программирования.
+ *Легкость интеграции*: LSP делает легко интегрировать серверы языка с
  редакторами кода и IDE, без необходимости реализовывать сложную логику.
+ *Расширяемость*: LSP позволяет разработчикам создавать свои собственные
  серверы языка и добавлять новые функции к существующим.

Для написания LSP можно использовать библиотеки из семейства lsp-*, см.
[lsp](https://hackage.haskell.org/package/lsp) и по ссылкам в его README.

# Multi-exit loops

**Эта опция требует реализованную опцию парсинга!**

В языке Colon существует multi-exit loop - это тип цикла, который позволяет выходить из цикла не
только в конце его выполнения, но и в любой другой точке внутри цикла. Это
достигается с помощью специальных слов, которые позволяют прыгать к разным
меткам внутри цикла.

В Colon есть несколько слов, которые позволяют управлять multi-exit loops:

+ `LEAVE`: прыгает к концу цикла (т.е. происходит выход из цикла, никакие слова после `LEAVE` не выполняются)
+ `+LOOP`: (для `DO ... LOOP`) прыгает к началу цикла с инкрементом счетчика (инкремент берётся с вершины стека)

# Конструкция `case of endof endcase`

**Эта опция требует реализованную опцию парсинга!**

В Forth, конструкция `CASE ... OF ... ENDOF ... ENDCASE` - это тип условного
оператора, который позволяет выполнить разные действия в зависимости от значения
некоторой переменной или выражения.

```
CASE 
значение1 OF действие1 ENDOF 
значение2 OF действие2 ENDOF 
... 
значениеN OF действиеN ENDOF 
действиеX
ENDCASE
```
Здесь:

+ `CASE` - начало конструкции
+ `значение1`, `значение2`, ..., `значениеN` - значения, которые будут сравнены с текущим значением
+ `действие1`, `действие2`, ..., `действиеN` - действия, которые будут выполнены, если соответствующее значение совпадает с текущим значением
+ `действиеX` - действие, которое будет выполнено, если ни одно значение не совпало
+ `OF` - слово, которое указывает на начало действия для каждого значения
+ `ENDOF` - слово, которое указывает на конец действия для каждого значения
+ `ENDCASE` - конец конструкции

Слово `OF` сравнивает два значения на вершине стека, отбрасывает верхнее, если они не равны, и продолжает после слова `ENDOF`. Если значения были равны, отбрасываются оба значения и выполнение продолжается как обычно.

Слово `ENDOF` производит безусловный переход к метке после `ENDCASE`.

```
: cs1 CASE 1 OF 111 ENDOF 2 OF 222 ENDOF 3 OF 333 ENDOF 999 swap ENDCASE ; 3 cs1
> ok
| 333 <- Top

: cs2 CASE 1 OF 111 ENDOF 1 1 + OF 222 ENDOF 1 1 1 + + OF 333 ENDOF 999 swap ENDCASE ; 9 cs2
> ok
| 999 <- Top
```

**UPD 2025-01-18.** Как видно, значениями и действиями в `CASE` могут быть произвольные последовательности слов. В любом случае, `OF` проверяет два значения на вершине стека (которые, возможно, получились после выполнения этих последовательностей).

**UPD 2025-01-18.** Во втором примере слова `999 SWAP` после всех `ENDOF` будут выполняться, если ни один `OF` не сработал. В этом случае на вершину стека будет положено `999`, а затем это значение обменяно местами с тем, которое сравнивалось (которое было перед выполнением `CASE`). Слово `ENDCASE` выбросит верхнее значение со стека, поэтому на стеке останется значение `999`.

# Арифметические операции над числами с плавающей запятой

Для работы с числами с плавающей запятой (т.е. вещественными) добавляется возможность хранить на стеке не только целые числа, но и вещественные. Арифметические операции, в зависимости от типов операндов, кладут на стек либо целые, либо вещественные числа. 

Кроме того, добавляются слова:
- `F>S`, которое снимает со стека вещественное число, получает его целую часть и кладёт обратно на стек;
- `S>F`, которое снимает со стека целое число, преобразует его в вещественное число и кладёт на стек.

# json + api на типах + htmx = веб-интерпретатор (6)

Должна быть возможность запустить в режиме с API, когда по запросу, в теле которого содержится текст программы, API выдаёт результат её выполнения, или ошибки времени выполнения или компиляции. При необходимости получить или отправить данные - должны выдаваться соответствующие запросы через API. Весь этот API должен быть описан в типах (т.е. - на [servant](https://hackage.haskell.org/package/servant)).

Для клиентского приложения в том же API отдавать HTML-страницу, на которой можно вводить текст и запускать код со входными данными. Для простоты построения клиентского приложения можно использовать [htmx](https://htmx.org) - дополнительную библиотеку, которая позволяет выполнять HTTP-запросы на относительно чистом HTML (используя соответствующие атрибуты HTML).

# Пошаговая отладка

Интерпретатор должен предоставлять команды для запуска программы по отдельным шагам. Также должны быть команды, которые отобразят и позволят поменять состояние стека, словаря, памяти и т.п. 

# Конкурентное программирование

Для запуска кода на нескольких ядрах добавляются следующие слова:

- `RX ... END` - слова между `RX` и `END` запускаются на другом процессоре;
- `GVAR name` - определяет переменную, которая доступна на всех процессорах;
- `G!` - позволяет писать в переменную, определённую через `GVAR` (аналогично `!`, только для доступных для всех процессоров), чтение из неё производится обычным словом `@`.
