# Учебный язык программирования Colon

> Йоды магистра тайна речи раскрыта:
> Старым Форта программистом был он просто. 

Colon - минимальный диалект языка [Forth](https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)).

## Общее описание

Программы записываются в виде последовательности слов (лексем), разделённых пробельными символами, и обрабатываются в постфиксной записи (за исключением некоторых специальных слов).
Состояние работы программы - стек, в котором хранятся результаты.

В следующих разделах указаны примеры программ и результатов их выполнения. После каждой строки с программой будет записан ответ интерпретатора после символов `> ` (слово `ok` или какая-либо ошибка), в следующей строке после `| ` будет показано состояние стека. Вершина стека находится справа, на неё показывает стрелка `<- Top`. Для простоты каждый блок кода (отделённый пустой строкой) мы считаем отдельной программой и начинаем работу с пустого стека.

## Арифметика
В языке имеются базовые арифметические операции (`+ - * / MOD`).

```
1 2 3 + 
> ok
| 1 5 <- Top

1 2 3 + +
> ok
| 6 <- Top

1 2 3 + + +
> Stack underflow

1 2 -
> ok
| -1 <- Top

3 4 *
> ok
| 12 <- Top

4 5 /
> ok
| 0 <- Top

-12 5 MOD
> ok
| -2 <- Top

5 2 + 10 *
> ok
| 70 <- Top
```

Очевидно, скобки при постфиксной интерпретации выражений не нужны:
```
2 2 + 2 *
> ok
| 8 <- Top

2 2 2 * +
> ok
| 6 <- Top
```

**UPD 2024-11-23.**
Обратите внимание: минус всегда бинарный оператор; чтобы ввести отрицательное число (использовать унарный минус), нужно записать минус и число без пробела между ними:
```
-1
> ok
| -1 <- Top

1 1 -
> ok
| 0 <- Top

1 -
> Stack underflow
```

## Объявление новых слов

Интерпретатор разделяет входную последовательность на слова по пробельным символам и проверяет, есть ли указанные слова в словаре. Если есть, он выполняет соответствующй код (например, для слова `+` -- вытаскивает два элемента из стека, складывает их и кладёт в стек). Если нет -- пытается интерпретировать слово как число и в случае успеха кладёт его на стек. Если же и это не удаётся, выдаёт ошибку:

```
foo
> foo ?
```

Новые слова можно определять при помощи слов `:` и `;`: первое слово после двоеточия означает определяемое слово, остальные слова до точки с запятой (обратите внимание, она отделяется пробельными символами) -- определение этого слова. Например, чтобы `foo` добавляло 100 к вершине стека, нужно определить его так:

```
: foo 100 + ;
> ok
```

## Комментарии

В программе могут быть комментарии, записанные между круглыми скобками. Комментарии могут быть вложенными друг в друга:
```
( + 2 3 ( - 3 2 ) )
> ok
```

Для описания изменений стека будут использоваться комментарии следующего формата: `( до -- после )`, например, для `+` таким описанием будет `( n1 n2 -- сумма )`.

## Манипулирование стеком

Следующие слова манипулируют стеком:

- дублирование вершины стека: `DUP ( n -- n n )`;
- удаление вершины стека: `DROP ( n -- )`;
- обмен местами двух элементов на вершине стека: `SWAP ( n1 n2 -- n2 n1 )`;
- слово `OVER ( n1 n2 -- n1 n2 n1 )` берёт второй с вершины элемент стека и дублирует его на вершину;
- слово `ROT ( n1 n2 n3 -- n2 n3 n1 )` "вращает" верхние три элемента стека.

Примеры использования этих слов:

```
1 2 3 4 DUP
> ok
| 1 2 3 4 4 <- Top

1 2 3 4 DROP
> ok
| 1 2 3 <- Top

1 2 3 4 SWAP
> ok
| 1 2 4 3 <- Top

1 2 3 4 OVER
> ok
| 1 2 3 4 3 <- Top

1 2 3 4 ROT
> ok
| 1 3 4 2 <- Top
```

## Ввод-вывод

Для ввода-вывода можно использовать следующие слова:
- поглощение и вывод вершины стека: `. ( n -- )`
- вывод перевода строки: `CR ( -- )`
- вывод символа, код которого на вершине стека: `EMIT ( c -- )`
- пара слов `." "` используется для вывода строк: слово `."` обозначает начало строки, которая завершается кавычкой (она может не отделяться пробелом от предыдущего символа)
- ввод кода символа в стек: `KEY ( -- c )` - программа приостанавливается и ожидает нажатия любой клавиши; код нажатой клавиши кладётся в стек и программа продолжает выполнение

```
1 2 . . 3 . 4
> 2 1 3 ok 
| 4 <- Top

CR 100 . CR 200 .
> 
> 100
> 200 ok

87 emit 111 emit 119 emit 33 emit
> wow! ok

: hi ." Hello!" ;
hi
> Hello! ok
```

## Булевские значения

Число 0 считается ложным, любое другое - истинным (при этом операции, возвращающие булевские значения, используют `-1` для обозначения истинного значения)

Слова `=`, `<`, `>` вытаскивают два значения из вершины стека и возвращают истину, если они, соответственно, равны, более глубокое меньше, более глубокое больше:

```
3 4 =
> ok
| 0 <- Top

5 5 =
> ok
| -1 <- Top 

3 4 <
> ok
| -1 <- Top 

3 4 >
> ok
| 0 <- Top
```

Булевские значения можно комбинировать при помощи слов `AND OR INVERT`, соответствующих операциям И, ИЛИ, НЕ:
```
3 4 < 20 30 < AND 
> ok
| -1 <- Top

3 4 < 20 30 > OR
> ok
| -1 <- Top

3 4 < INVERT 
> ok
| 0 <- Top
```

## Условный оператор

Конструкция `IF ... [ELSE] ... THEN` является условным оператором (запись `[ELSE]` означает, что возможны два варианта: `IF ... THEN` и `IF ... ELSE ... THEN`). Эту конструкцию можно использовать только в объявлении нового слова.

Слово `IF` проверяет верхнее значение на стеке, если оно истинное (не равно 0), выполняются операции после `IF` до `ELSE` (или до `THEN`, если слово `ELSE` отсутствует). Если значение ложное, выполняются операции между `ELSE` и `THEN` (или не выполняется никаких операций, если слово `ELSE` отсутствует).

```
: buzz?  5 mod 0 = if ." Buzz" then ;
3 buzz?
4 buzz?
5 buzz?
> ok
> ok
> Buzz ok
```

```
: is-it-zero?  0 = if ." Yes" else ." No" then ;
0 is-it-zero?
1 is-it-zero?
2 is-it-zero?
> Yes ok
> No ok
> No ok
```

## Циклы

Слова `DO ... I ... LOOP` позволяют выполнять циклы с заданным количеством повторений:
- Слово `DO` поглощает два верхних значения со стека (начальное и конечное значения) и выполняет соответствующее количество повторений операций между соответствующими словами `DO` и `LOOP`. 
- Слово `I` кладёт на стек текущее значение индекса.

Так же, как и условный оператор, `DO ... I ... LOOP` можно использовать только внутри определений

```
: loop-test 5 0 DO I LOOP ;
loop-test
> ok
| 0 1 2 3 4 <- Top
```

## Доступ к памяти

Язык позволяет хранить данные в переменных и константах, чтобы упростить работу со стеком.

- Для объявления переменных используется ключевое слово `VARIABLE`, например, `VARIABLE v1` объявляет переменную с именем `v1`. Далее слово `v1` может использоваться в программе и возвращает адрес, по которому находится значение переменной (в примере будет использоваться адрес 1000, но он может быть произвольным)
- Для задания значения переменной используется слово `!`, для получения значения переменной - слово `@`:
```
VARIABLE v1
v1 .
123 v1 !
v1 @
> ok
> 1000 ok
> ok
> ok
| 123 <- Top
```

Для удобства работы с переменными определены дополнительные слова
- слово `?` получает значение и выводит его (т.е. определено как `@ .`)
- слова `+! -! *! /! MOD!`, соответственно, увеличивают, уменьшают, умножают, делят нацело и получают остаток от деления переменной на число:
```
VARIABLE v2
100 v2 ! v2 ?
5 v2 +! v2 ?
4 v2 -! v2 ?
10 v2 MOD! v2 ?
5 v2 *! v2 ?
2 v2 /! v2 ?
> ok
> 100 ok
> 105 ok
> 101 ok
> 1 ok
> 5 ok
> 2 ok
```

Константы определяются при помощи слова `CONSTANT`. В отличие от переменных, значением константы является сама константа (т.е. в использовании `@` нет необходимости):
```
42 CONSTANT answer
answer
> ok
> ok
| 42 <- Top
```

