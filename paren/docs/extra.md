# Дополнительные опции для Paren

Смотрите описание тех опций, которые вы выбрали.

# loop

Конструкция `loop` - это один из наиболее универсальных и мощных инструментов
для повторения выполнения выражений. Он позволяет выполнять различные виды
циклов, включая итерации по коллекциям, счётчики и многомерные циклы.

Синтаксис `loop` достаточно гибок и может выглядеть следующим образом:
```lisp
(loop [ключевое-слово1 значение1] [ключевое-слово2 значение2] ... [выражение для
  выполнения])
```

Здесь `[ключевое-слово1 значение1]` и т.п. - это спецификации, определяющие
поведение цикла, а `[выражение для выполнения]` - это то, что будет выполняться
внутри цикла.

Некоторые из ключевых слов, используемых в `loop`, включают:
- `for`: используется для указания переменной, которая меняется в процессе итерации;
- `in`: используется для итерации по списку;
- `from`/`to`: указывают диапазон чисел для счётчика;
- `while`/`until`: условия продолжения или остановки цикла;
- `do`: выполняет выражение в теле цикла;
- `collect`: собирает результаты выполнения выражений внутри цикла;
- `sum`: суммирует значения.

В случае нескольких слов `for`, итерация по ним проходит параллельно.
Для каждого `for` должно быть указано либо `in`, либо `from`/`to`. Часть `to` опциональна.

В цикле может быть только одно выражение `collect`, либо только одно выражение `sum`.

1. *Простой счётчик:*
```lisp
   (loop for i from 1 to 5 do (print i))
```
   Выводит числа от 1 до 5.

2. *Итерация по списку:*
```lisp
   (loop for elem in '(a b c) for idx from 1 to 10 do (print idx elem))
```
   Выводит каждый элемент списка `(a b c)` и его индекс.

3. *Сбор результатов:*
```lisp
   (loop for x from 1 to 5 collect (* x x))
```
   Возвращает список квадратов чисел от 1 до 5, т.е. `(1 4 9 16 25)`.

4. *Условный выход из цикла:*
```lisp
   (loop for i from 1 do (print i) while (< i 10))
```
   Выводит числа от 1 до 9, поскольку цикл останавливается при `i >= 10`.

5. *Вложенные циклы:*
```lisp
   (loop for i from 1 to 3 do (loop for j from 1 to 3 do (print (list i j))))
```
   Выводит все возможные пары чисел `(i j)`, где `i` и `j` варьируются от 1
   до 3.

# Макросы

Макросы - это способ расширить синтаксис языка без изменения самого
языка. Макрос - это функция, которая принимает код в качестве аргумента и
возвращает новый код, который затем выполняется интерпретатором или компилятором.

1. Когда вы определяете макрос, вы фактически создаёте функцию, которая будет
   обрабатывать код и возвращать новый код.
2. *Расширение макроса*: Перед выполнением кода интерпретатор проходит через
   исходный код и проверяет наличие вызовов макросов. Если он находит такой
   вызов, он запускает соответствующую функцию-макрос, передавая ей необходимые
   аргументы.
3. *Генерация нового кода*: Функция-макрос обрабатывает полученные аргументы и
   генерирует новый код, который затем заменяет исходный вызов макроса в
   программе.

В макросах могут использоваться следующие выражения:
- `(quasiquote datum)` (или синтаксический сахар для этого - обратный апостроф `` `(datum)``). Работает так же, как `quote`, если внутри `datum` (произвольного S-выражения) нет выражений `unquote` или `unquote-splicing`;
- `(unquote expr)` (или синтаксический сахар - запятая `,expr`). Вычисляет значение выражения `expr` и подставляет вместо формы `(unquote expr)`;
- `(unquote-splicing expr)` (или синтаксический сахар - `,@expr`). Вычисляет значение выражения `expr`, которое должно быть списком, и подставляет вместо `(unquote-splicing expr)` все значения этого списка.

Например:
```lisp 
(quasiquote (0 1 2))
;; '(0 1 2)

(quasiquote (0 (unquote (+ 1 2)) 4))
;; '(0 3 4)

(quasiquote (0 (unquote-splicing (list 1 2)) 4))
;; '(0 1 2 4)

(quasiquote (0 (unquote-splicing 1) 4))
;; должен выдать ошибку, поскольку результат unquote-splicing не является списком

(quasiquote (0 (unquote-splicing 1)))
;; '(0 . 1)

`(0 1 2)
;; '(0 1 2)

`(1 ,(+ 1 2) 4)
;; '(1 3 4)

`(1 ,@(list 1 2) 4)
;; '(1 1 2 4)
```

Формы quasiquote могут быть вложенными, тогда потребуется несколько вложений unquote и unquote-splicing для их вычисления:
```lisp 
`(1 `,(+ 1 ,(+ 2 3)) 4)
;; '(1 `,(+ 1 5) 4)

`(1 ```,,@,,@(list (+ 1 2)) 4)
;; '(1 ```,,@,3 4)
```

Вне quasiquote формы unquote и unquote-splicing являются ошибочными.

Для того, чтобы получить "свежее" имя переменной, можно использовать функцию `gensym`.

# cadr 

Функции `car` и `cdr` возвращают голову и хвост списка. При работе с большими и сложными структурами может быть не очень удобно использовать много вложений этих функций.

Предоставьте для удобства пользователя функции с названиями вида `caar`, `cadr`, `cddr`, `caaar`, `caadr`, ... (с произвольным количеством и порядком букв `a` и `d` в середине). Они должны работать как соответствующие последовательности вложенных вызовов `car` и `cdr`:
```lisp 
(caar X)                                ; (car (car X))
(cadr X)                                ; (car (cdr X))
(cddr X)                                ; (cdr (cdr X))
;; ...
(caadr X)                               ; (car (car (cdr X)))
;; ...
```

# Работа с переменными

Выражение `(set! var expr)` меняет значение переменной `var` на значение выражения `expr`. Переменная должна быть объявлена ранее при помощи `define`

# Работа со строками

Литералы-строки задаются в двойных кавычках: `"string"`. Внутри них можно экранировать кавычки и обратный слэш, например, чтобы задать строку, содержащую кавычку и обратный слэш: `"\"\\"`.

Для работы со строками определены следующие выражения:
- `(string? x)` - возвращает, является ли `x` строкой;
- `(string-length x)` - возвращает длину строку `x` в символах;
- `(string=? x y)` - сравнивает строки `x` и `y` на равенство;
- `(substring x start end)` - возвращает подстроку `x`, которая начинается с индекса `start` и заканчивается индексом `end` (индексация с нуля);
- `(string-append x ...)` - возвращает новую строку, являющуюся конкатенацией заданных строк.

# Работа с исключениями

Добавляются следующие выражения:
- `(with-exception-handler handler thunk)` - запускает `thunk` (который должен быть функцией от 0 аргументов); если при работе возникает ошибка, с ней в качестве аргумента запускается `handler` (который должен быть функцией от 1 аргумента);
- `(raise err)` - вызывает ошибку `err`, где `err` должен быть получен в результате вызова `error`;
- `(error message x ...)` - создаёт ошибку с сообщением `message` и произвольными выражениями `x ...`.

Если ошибка возникает, а ближайшего `with-exception-handler` нет, нужно выдать стек вызовов и информацию об ошибке.

Также аналогичным образом должна быть изменена работа с теми ошибками, которые имеются сейчас.

# json + api на типах + htmx = веб-интерпретатор (6)

Должна быть возможность запустить в режиме с API, когда по запросу, в теле которого содержится текст программы, API выдаёт результат её выполнения, или ошибки времени выполнения или компиляции. При необходимости получить или отправить данные - должны выдаваться соответствующие запросы через API. Весь этот API должен быть описан в типах (т.е. - на [servant](https://hackage.haskell.org/package/servant)).

Для клиентского приложения в том же API отдавать HTML-страницу, на которой можно вводить текст и запускать код со входными данными. Для простоты построения клиентского приложения можно использовать [htmx](https://htmx.org) - дополнительную библиотеку, которая позволяет выполнять HTTP-запросы на относительно чистом HTML (используя соответствующие атрибуты HTML).

# конкурентное программирование (3)
# опциональная строгая система типов (3) 
# проверяемая перед запуском (4)
