# Дополнительные опции для Paren

Смотрите описание тех опций, которые вы выбрали.

# loop

Конструкция `loop` - это один из наиболее универсальных и мощных инструментов
для повторения выполнения выражений. Он позволяет выполнять различные виды
циклов, включая итерации по коллекциям, счётчики и многомерные циклы.

Синтаксис `loop` достаточно гибок и может выглядеть следующим образом:
```lisp
(loop [ключевое-слово1 значение1] [ключевое-слово2 значение2] ... [выражение для
  выполнения])
```

Здесь `[ключевое-слово1 значение1]` и т.п. - это спецификации, определяющие
поведение цикла, а `[выражение для выполнения]` - это то, что будет выполняться
внутри цикла.

Некоторые из ключевых слов, используемых в `loop`, включают:
- `for`: используется для указания переменной, которая меняется в процессе итерации;
- `in`: используется для итерации по списку;
- `from`/`to`: указывают диапазон чисел для счётчика;
- `while`/`until`: условия продолжения или остановки цикла;
- `do`: выполняет выражение в теле цикла;
- `collect`: собирает результаты выполнения выражений внутри цикла;
- `sum`: суммирует значения.

В случае нескольких слов `for`, итерация по ним проходит параллельно.
Для каждого `for` должно быть указано либо `in`, либо `from`/`to`. Часть `to` опциональна.

В цикле может быть только одно выражение `collect`, либо только одно выражение `sum`.

1. *Простой счётчик:*
```lisp
   (loop for i from 1 to 5 do (print i))
```
   Выводит числа от 1 до 5.

2. *Итерация по списку:*
```lisp
   (loop for elem in '(a b c) for idx from 1 to 10 do (print idx elem))
```
   Выводит каждый элемент списка `(a b c)` и его индекс.

3. *Сбор результатов:*
```lisp
   (loop for x from 1 to 5 collect (* x x))
```
   Возвращает список квадратов чисел от 1 до 5, т.е. `(1 4 9 16 25)`.

4. *Условный выход из цикла:*
```lisp
   (loop for i from 1 do (print i) while (< i 10))
```
   Выводит числа от 1 до 9, поскольку цикл останавливается при `i >= 10`.

5. *Вложенные циклы:*
```lisp
   (loop for i from 1 to 3 do (loop for j from 1 to 3 do (print (list i j))))
```
   Выводит все возможные пары чисел `(i j)`, где `i` и `j` варьируются от 1
   до 3.

# Макросы (1)

Макросы - это способ расширить синтаксис языка без изменения самого
языка. Макрос - это функция, которая принимает код в качестве аргумента и
возвращает новый код, который затем выполняется интерпретатором или компилятором.

1. Когда вы определяете макрос, вы фактически создаёте функцию, которая будет
   обрабатывать код и возвращать новый код.
2. *Расширение макроса*: Перед выполнением кода интерпретатор проходит через
   исходный код и проверяет наличие вызовов макросов. Если он находит такой
   вызов, он запускает соответствующую функцию-макрос, передавая ей необходимые
   аргументы.
3. *Генерация нового кода*: Функция-макрос обрабатывает полученные аргументы и
   генерирует новый код, который затем заменяет исходный вызов макроса в
   программе.

В макросах могут использоваться следующие выражения:
- `(quasiquote datum)` (или синтаксический сахар для этого - обратный апостроф `` `(datum)``). Работает так же, как `quote`, если внутри `datum` (произвольного S-выражения) нет выражений `unquote` или `unquote-splicing`;
- `(unquote expr)` (или синтаксический сахар - запятая `,expr`). Вычисляет значение выражения `expr` и подставляет вместо формы `(unquote expr)`;
- `(unquote-splicing expr)` (или синтаксический сахар - `,@expr`). Вычисляет значение выражения `expr`, которое должно быть списком, и подставляет вместо `(unquote-splicing expr)` все значения этого списка.

Например:
```lisp 
(quasiquote (0 1 2))
;; '(0 1 2)

(quasiquote (0 (unquote (+ 1 2)) 4))
;; '(0 3 4)

(quasiquote (0 (unquote-splicing (list 1 2)) 4))
;; '(0 1 2 4)

(quasiquote (0 (unquote-splicing 1) 4))
;; должен выдать ошибку, поскольку результат unquote-splicing не является списком

(quasiquote (0 (unquote-splicing 1)))
;; '(0 . 1)

`(0 1 2)
;; '(0 1 2)

`(1 ,(+ 1 2) 4)
;; '(1 3 4)

`(1 ,@(list 1 2) 4)
;; '(1 1 2 4)
```

Формы quasiquote могут быть вложенными, тогда потребуется несколько вложений unquote и unquote-splicing для их вычисления:
```lisp 
`(1 `,(+ 1 ,(+ 2 3)) 4)
;; '(1 `,(+ 1 5) 4)

`(1 ```,,@,,@(list (+ 1 2)) 4)
;; '(1 ```,,@,3 4)
```

Вне quasiquote формы unquote и unquote-splicing являются ошибочными.

Для того, чтобы получить "свежее" имя переменной, можно использовать функцию `gensym`.

# cadr 
~c[ad]+r~-like функции для доступа к ячейке по произвольному пути (1)
# работа с переменными (1)
# работа со строками (1)
# работа с исключениями (2)
# опциональная строгая система типов (3) 
# проверяемая перед запуском (4)
# конкурентное программирование (3)
# json + api на типах + htmx = веб-интерпретатор (6)
