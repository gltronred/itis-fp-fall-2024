# Учебный язык программирования Paren

>    Some said the world should be in Perl;
>    Some said in Lisp.
>    Now, having given both a whirl,
>    I held with those who favored Perl.
>    But I fear we passed to men
>    A disappointing founding myth,
>    And should we write it all again,
>    I'd end it with
>    A close-paren.
>
> With Apologies to Robert Frost, https://xkcd.com/312

Paren -- минимальный диалект языка [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language))

## Синтаксис

Весь код и данные записываются в виде S-выражений. S-выражение -- это либо *атом* (`x`), либо *cons-ячейка* (`( x . y )`) из S-выражений `x` и `y`. Атомами могут быть *символы* (последовательности из букв, цифр и символов `! $ % & * + - . / : < = > ? @ ^ _ ~`, которые не начинаются с числа); *числа* (целые и вещественные); *строки* (последовательности символов, записанные в кавычках `"`); *булевские литералы* (истина `#t` и ложь `#f`).

Для удобства запись вида `(x y z)` эквивалентна `(x . (y . (z . NIL)))`. Атом `NIL` обозначает пустой список и может быть записан как `()`.

Комментарии начинаются с `;` и продолжаются до конца строки.

## Семантика

Некоторые выражения вычисляются иначе, чем остальные. Такие выражения мы будем называть *специальными формами*; отличить специальную форму можно по первому элементу в выражении, все специальные формы будут описаны далее. Остальные вычисляются по общим правилам следующим образом:
- вычисляются значения всех подвыражений;
- значением числа, булевского литерала и значением строки являются сами эти число, булевский литерал и строка, соответственно;
- значением символа `x` является то значение, которое связано с ним (при помощи `define`, см. ниже)
- значением выражения `(f x1 x2 ... xn)` является результат вызова функции `f` с аргументами `x1`, `x2`, ..., `xn`.

В стандартной библиотеке определены следующие функции:
- арифметические `+ - * /`;
- сравнения `= > < >= <=`;
- логические операторы `and or not`; любое значение, кроме `#f` и `nil` является истинным;
- работы с cons-ячейками `cons car cdr null?`: функция `cons` создаёт ячейку (и имеет синтаксический сахар вида `(x . y)` для `(cons x y)`), `car` получает первый элемент ячейки, `cdr` - второй, `null?` возвращает `#t`, если аргумент - пустой список;

## Специальные формы

### quote

Выражение `(quote smth)` используется, чтобы НЕ вычислять выражение `smth`; в качестве `smth` может выступать любое выражение.

Для `quote` есть синтаксический сахар: выражение `'smth` эквивалентно выражению `(quote smth)`.

### define

Выражение `(define var value)` связывает имя `var` с выражением `value`, при этом вычисления `value` не происходит.

### lambda

Выражение `(lambda args body)` задаёт анонимную функцию. В `args` записаны переменные, которые связываются с переданными значениями в месте вызова; тело `body` вычисляется при вызове функции. При каждом вызове связываются свежие переменные, они доступны только внутри тела.

Возможны следующие варианты для `args`:
- `(v1 v2 ... vn)` - функция принимает `n` аргументов, каждое значение записывается в свежей переменной;
- `v` - функция принимает произвольное количество аргументов, все переданные значения записываются в список в свежей переменной;
- `(v1 v2 ... vn . rest)` - функция принимает `n` или более аргументов, первые `n` связываются со свежими переменными `v1` ... `vn`, а остальные записываются в список в свежей переменной `rest`.

Примеры:
```scheme
((lambda (x y) (+ x y))
 3 5)
;; 8

((lambda x x) 3 4 5 6)
;; (3 4 5 6)

((lambda (x y . z) z) 3 4 5 6)
;; (5 6)
```

### if

Выражение `(if test consequent alternative)` задаёт условный оператор. Вычисляется значение выражения `test`, если оно истинно, вычисляется выражение `consequent`, если ложно - `alternative`.

Существует альтернативная форма `(if test consequent)`, в которой при ложном значении `test` результат вычисления определяется реализацией.
